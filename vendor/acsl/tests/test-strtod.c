/*
 * strtod() unit tests for the ACSL library
 *
 * (C) Copyright 2021 Pedro Gimeno Fortea
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
 * IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <errno.h>

#define LEN -314159

int strtod_test(const char *s, char **p, double expect, int ofs, int eno, int line)
{
  errno = 0;
  double actual = strtod(s, p);
  int save_errno = errno;
  if (ofs == LEN) ofs = strlen(s);
  int err = 0;
  if (copysign(1.0, actual) != copysign(1.0, expect))
  {
    printf("strtod line %d: Signs don't match: got %.13a, want %.13a\n", line, actual, expect);
    err = 1;
  }
  if ((!isnan(actual) || !isnan(expect)) && (actual != expect))
  {
    printf("strtod line %d: Values don't match: got %.13a, want %.13a\n", line, actual, expect);
    err = 1;
  }
  if (p && *p-s != ofs)
  {
    printf("strtod line %d: Wrong offset: got %d, want %d\n", line, *p-s, ofs);
    err = 1;
  }
  if (save_errno != eno)
  {
    printf("strtod line %d: ERRNO: got %d, want %d\n", line, save_errno, eno);
    err = 1;
  }
  return err;
}
#define TESTTOD(s, ex, ofs) (errors+=strtod_test(s, e, ex, ofs, 0, __LINE__))
#define TESTTOD_E(s, ex, ofs) (errors+=strtod_test(s, e, ex, ofs, ERANGE, __LINE__))
#define TESTEXACT(n) (errors+=strtod_test(#n, e, n, sizeof(#n)-1, 0, __LINE__))
#define TESTEXACT_E(n) (errors+=strtod_test(#n, e, n, sizeof(#n)-1, ERANGE, __LINE__))
#define TESTEXACTNP(n) (errors+=strtod_test(#n, e, n##p0, sizeof(#n)-1, 0, __LINE__))
#define TESTEXACTNE(n) (errors+=strtod_test(#n, e, n##e0, sizeof(#n)-1, 0, __LINE__))

int main()
{
  char *a;
  char **e = &a;
  int errors = 0;

  TESTTOD("", 0., 0); // handled as decimal
  TESTTOD("-", 0., 0); // handled as decimal
  TESTTOD("0", 0., LEN); // handled as decimal
  TESTTOD("-0", -0., LEN); // handled as decimal
  TESTTOD("0x", 0., 1);
  TESTTOD("-0x", -0., 2);
  TESTTOD("0x0", 0., LEN);
  TESTTOD("0x0 ", 0., 3);
  TESTTOD("-0x0", -0., LEN);
  TESTTOD("0x0p", 0., 3);
  TESTTOD("-0x0p", -0., 4);
  TESTTOD("0x0p0", 0., LEN);
  TESTTOD("0x0p0 ", 0., 5);
  TESTTOD("-0x0p0", -0., LEN);
  TESTTOD(" 0x.", 0., 2);
  TESTTOD("+0x.", 0., 2);
  TESTTOD("-0x.", -0., 2);
  TESTTOD(" 0x.p0", 0., 2);
  TESTTOD("+0x.p0", 0., 2);
  TESTTOD("-0x.p0", -0., 2);
  TESTTOD("0x.0", 0., LEN);
  TESTTOD("0x0.", 0., LEN);
  TESTTOD("0x0..", 0., 4);
  TESTTOD("0x0.0.0", 0., 5);
  TESTTOD("0xp0", 0., 1);
  TESTTOD("0x0p1", 0., LEN);
  TESTTOD("0x0p+1", 0., LEN);
  TESTTOD("0x0p-1", 0., LEN);
  TESTTOD("0x0p+-1", 0., 3);
  TESTTOD("0x0p-+1", 0., 3);
  TESTTOD("0x0p--1", 0., 3);
  TESTTOD("0x0p++1", 0., 3);
  TESTTOD("0x1e0", 0x1e0p0, LEN);

  TESTEXACTNP(0x1);
  TESTEXACTNP(+0x2);
  TESTEXACTNP(-0x4);
  TESTEXACTNP(0x8);
  TESTEXACTNP(+0xa);
  TESTEXACTNP(-0x11);
  TESTEXACTNP(0x21);
  TESTEXACTNP(+0x41);
  TESTEXACTNP(-0x81);
  TESTEXACTNP(0x101);
  TESTEXACTNP(+0x201);
  TESTEXACTNP(-0x401);
  TESTEXACTNP(0x801);
  TESTEXACTNP(+0x1001);
  TESTEXACTNP(-0x2001);
  TESTEXACTNP(0x4001);
  TESTEXACTNP(0x8001);
  TESTEXACTNP(0x10001);
  TESTEXACTNP(0x20001);
  TESTEXACTNP(0x40001);
  TESTEXACTNP(0x80001);
  TESTEXACTNP(0x100001);
  TESTEXACTNP(0x200001);
  TESTEXACTNP(0x400001);
  TESTEXACTNP(0x800001);
  TESTEXACTNP(0x1000001);
  TESTEXACTNP(0x2000001);
  TESTEXACTNP(0x4000001);
  TESTEXACTNP(0x8000001);
  TESTEXACTNP(0x10000001);
  TESTEXACTNP(0x20000001);
  TESTEXACTNP(0x40000001);
  TESTEXACTNP(0x80000001);
  TESTEXACTNP(0x100000001);
  TESTEXACTNP(0x200000001);
  TESTEXACTNP(0x400000001);
  TESTEXACTNP(0x800000001);
  TESTEXACTNP(0x1000000001);
  TESTEXACTNP(0x2000000001);
  TESTEXACTNP(0x4000000001);
  TESTEXACTNP(0x8000000001);
  TESTEXACTNP(0x10000000001);
  TESTEXACTNP(0x20000000001);
  TESTEXACTNP(0x40000000001);
  TESTEXACTNP(0x80000000001);
  TESTEXACTNP(0x100000000001);
  TESTEXACTNP(0x200000000001);
  TESTEXACTNP(0x400000000001);
  TESTEXACTNP(0x800000000001);
  TESTEXACTNP(0x1000000000001);
  TESTEXACTNP(0x2000000000001);
  TESTEXACTNP(0x4000000000001);
  TESTEXACTNP(0x8000000000001);
  TESTEXACTNP(0x10000000000001);
  TESTEXACTNP(0x20000000000001);
  TESTEXACTNP(0x40000000000001);
  TESTEXACTNP(0x80000000000001);
  TESTEXACTNP(0x100000000000001);
  TESTEXACTNP(0x200000000000001);
  TESTEXACTNP(0x400000000000001);
  TESTEXACTNP(0x800000000000001);
  TESTEXACTNP(0x.1);
  TESTEXACTNP(0x.2);
  TESTEXACTNP(0x.4);
  TESTEXACTNP(0x.8);
  TESTEXACTNP(0x.01);
  TESTEXACTNP(0x.02);
  TESTEXACTNP(0x.04);
  TESTEXACTNP(0x.08);
  TESTEXACTNP(0x.001);
  TESTEXACTNP(0x.002);
  TESTEXACTNP(0x.004);
  TESTEXACTNP(0x.008);
  TESTEXACTNP(0x.10000000000001);
  TESTEXACTNP(0x.20000000000002);
  TESTEXACTNP(0x.40000000000004);
  TESTEXACTNP(0x.80000000000008);
  TESTEXACT(0x1p0);
  TESTEXACT(0x1p+0);
  TESTEXACT(0x1p+1);
  TESTEXACT(0x1p-1);
  TESTEXACT(0x2p0);
  TESTEXACT(0x4p0);
  TESTEXACT(0x8p0);
  TESTEXACT(0xap0);
  TESTEXACT(0x11p0);
  TESTEXACT(0x21p0);
  TESTEXACT(0x41p0);
  TESTEXACT(0x81p0);
  TESTEXACT(0x101p0);
  TESTEXACT(0x201p0);
  TESTEXACT(0x401p0);
  TESTEXACT(0x801p0);
  TESTEXACT(0x1001p0);
  TESTEXACT(0x2001p0);
  TESTEXACT(0x4001p0);
  TESTEXACT(0x8001p0);
  TESTEXACT(0x10001p0);
  TESTEXACT(0x20001p0);
  TESTEXACT(0x40001p0);
  TESTEXACT(0x80001p0);
  TESTEXACT(0x100001p0);
  TESTEXACT(0x200001p0);
  TESTEXACT(0x400001p0);
  TESTEXACT(0x800001p0);
  TESTEXACT(0x1000001p0);
  TESTEXACT(0x2000001p0);
  TESTEXACT(0x4000001p0);
  TESTEXACT(0x8000001p0);
  TESTEXACT(0x10000001p0);
  TESTEXACT(0x20000001p0);
  TESTEXACT(0x40000001p0);
  TESTEXACT(0x80000001p0);
  TESTEXACT(0x100000001p0);
  TESTEXACT(0x200000001p0);
  TESTEXACT(0x400000001p0);
  TESTEXACT(0x800000001p0);
  TESTEXACT(0x1000000001p0);
  TESTEXACT(0x2000000001p0);
  TESTEXACT(0x4000000001p0);
  TESTEXACT(0x8000000001p0);
  TESTEXACT(0x10000000001p0);
  TESTEXACT(0x20000000001p0);
  TESTEXACT(0x40000000001p0);
  TESTEXACT(0x80000000001p0);
  TESTEXACT(0x100000000001p0);
  TESTEXACT(0x200000000001p0);
  TESTEXACT(0x400000000001p0);
  TESTEXACT(0x800000000001p0);
  TESTEXACT(0x1000000000001p0);
  TESTEXACT(0x2000000000001p0);
  TESTEXACT(0x4000000000001p0);
  TESTEXACT(0x8000000000001p0);
  TESTEXACT(0x10000000000001p0);
  TESTEXACT(0x20000000000001p0);
  TESTEXACT(0x40000000000001p0);
  TESTEXACT(0x80000000000001p0);
  TESTEXACT(0x100000000000001p0);
  TESTEXACT(0x200000000000001p0);
  TESTEXACT(0x400000000000001p0);
  TESTEXACT(0x800000000000001p0);
  TESTEXACTNP(0x1);
  TESTEXACTNP(0x10.2);
  TESTEXACTNP(0x2.3456789ABCDEF);
  TESTEXACT(0X2.3456789abcdefP1);
  TESTEXACT(0x1.2345678p0);
  TESTEXACT(0x0.12345678p0);
  TESTEXACT(0x0.22345678p0);
  TESTEXACT(0x0.42345678p0);
  TESTEXACT(0x0.82345678p0);
  TESTEXACT(0x0.012345678p0);
  TESTEXACT(0x0.022345678p0);
  TESTEXACT(0x0.082345678p0);
  TESTEXACT(0x0.082345678p-102);
  TESTEXACT(0x182345678afedc000000000000000000000000000000000000000000p-1234);
  TESTTOD_E("0x1p1024", INFINITY, LEN);
  TESTTOD_E("0x0.8p1025", INFINITY, LEN); // libc6 2.24 fails to set errno; 2.28 does
  TESTTOD_E("0x.8p1025", INFINITY, LEN); // libc6 2.24 fails to set errno; 2.28 does
  TESTEXACT(0x0.8p1024);
  TESTEXACT(0x1.0p1023);
  TESTEXACT(0x1.FFFFFFFFFFFFFp1023);
  TESTEXACT(0x1.0000000000000p-1022);

  // Denormal tests
  TESTEXACT  (0x0.FFFFFFFFFFFFFp-1022);
  TESTEXACT  (0x0.7FFFFFFFFFFFFp-1022);
  TESTEXACT  (0x0.3FFFFFFFFFFFFp-1022);
  TESTEXACT  (0x1.FFFFFFFFFFFFEp-1023);
  TESTEXACT_E(0x0.0144444444444444p-1022);
  TESTEXACT_E(0x1.4444444444444p-1030);
  TESTEXACT  (0x1p-1074);
  // This is a discrepancy between libc6 2.24/2.28 and our library.
  // This has more than 53 bits therefore it doesn't underflow, but glibc
  // marks this as an underflow.
  TESTEXACT_E(0x1.0000000000000000000000000001p-1030);
  TESTTOD_E("0x1.0p-1075", 0., LEN);
  TESTTOD_E("0x0.8p-1074", 0., LEN);
  TESTTOD_E("0x.8p-1074", 0., LEN); // Python bugged on this: https://bugs.python.org/issue44954

  // Rounding tests
  TESTTOD("0x1.00000000000008p0", 0x1p0, LEN);
  TESTTOD("0x0.80000000000004p1", 0x1p0, LEN);
  TESTTOD("0x0.40000000000002p2", 0x1p0, LEN);
  TESTTOD("0x0.20000000000001p3", 0x1p0, LEN);
  TESTTOD("0x0.100000000000008p4", 0x1p0, LEN);
  TESTTOD("0x1.0000000000000Cp0", 0x1.0000000000001p0, LEN);
  TESTTOD("0x0.80000000000006p1", 0x1.0000000000001p0, LEN);
  TESTTOD("0x1.00000000000009p0", 0x1.0000000000001p0, LEN);
  TESTTOD("0x0.80000000000005p1", 0x1.0000000000001p0, LEN);
  TESTTOD("0x1.000000000000088p0", 0x1.0000000000001p0, LEN);
  TESTTOD("0x0.800000000000042p1", 0x1.0000000000001p0, LEN);
  TESTTOD("0x1.000000000000080000000000000000000000p0", 0x1p0, LEN);
  TESTTOD("0x0.800000000000040000000000000000000000p1", 0x1p0, LEN);
  TESTTOD("0x1.000000000000080000000000000000000001p0", 0x1.0000000000001p0, LEN);
  TESTTOD("0x0.800000000000040000000000000000000001p1", 0x1.0000000000001p0, LEN);
  TESTTOD("0x1.0000000000001800000000p0", 0x1.0000000000002p0, LEN);
  TESTTOD("0x0.8000000000000C00000000p1", 0x1.0000000000002p0, LEN);
  TESTTOD("0x1.0000000000001000000001p0", 0x1.0000000000001p0, LEN);
  TESTTOD("0x1.00000000000014p0", 0x1.0000000000001p0, LEN);
  TESTTOD("0x1.0000000000001800000001p0", 0x1.0000000000002p0, LEN);
  TESTTOD("0x0.8000000000000C00000001p1", 0x1.0000000000002p0, LEN);
  TESTTOD("0x1.FFFFFFFFFFFFF8p0", 0x1p1, LEN);

  /* denormal + rounding tests */
  TESTTOD_E("0x0.81p-1074", 0x1p-1074, LEN);
  TESTTOD_E("0x0.80p-1074", 0x0, LEN);
  TESTTOD_E("0x1p-1075", 0x0, LEN);
  TESTTOD_E("0x1.01p-1075", 0x1p-1074, LEN);
  TESTTOD_E("0x.FFFFFFFFFFFFF7FFFFFFFFFFFFp-1022", 0x.FFFFFFFFFFFFFp-1022, LEN);
  TESTTOD_E("0x.FFFFFFFFFFFFF8000000000000p-1022", 0x1p-1022, LEN);
  TESTTOD_E("0x.001FFFFFFFFFF8000000000000p-1022", 0x0.002p-1022, LEN);
  TESTTOD_E("0x.FFFFFFFFFFFFE8000000000000p-1022", 0x.FFFFFFFFFFFFEp-1022, LEN);
  TESTTOD_E("0x.001FFFFFFFFFE8000000000000p-1022", 0x.001FFFFFFFFFEp-1022, LEN);
  TESTTOD_E("0x.FFFFFFFFFFFFE8000000000001p-1022", 0x.FFFFFFFFFFFFFp-1022, LEN);
  TESTTOD_E("0x.001FFFFFFFFFE8000000000001p-1022", 0x.001FFFFFFFFFFp-1022, LEN);
  TESTTOD_E("0x0.000100000000000009p-1022", 0x0.0001p-1022, LEN);
  TESTTOD  ("0x0.000100000000000009p-1000", 0x0.00010000000000001p-1000, LEN);
  TESTTOD_E("0x0.000200000000000009p-1022", 0x0.0002p-1022, LEN);
  TESTTOD  ("0x0.000200000000000009p-1000", 0x0.00020000000000001p-1000, LEN);
  TESTTOD_E("0x0.00010000000000000801p-1022", 0x0.0001p-1022, LEN);
  TESTTOD  ("0x0.00010000000000000801p-1000", 0x0.00010000000000001p-1000, LEN);
  TESTTOD_E("0x0.00020000000000000801p-1022", 0x0.0002p-1022, LEN);
  TESTTOD  ("0x0.00020000000000000801p-1000", 0x0.00020000000000001p-1000, LEN);

  // DECIMAL

  // Syntax
  TESTEXACTNE(0.);
  TESTEXACTNE(0.0);
  TESTEXACTNE(.0);
  TESTTOD(".", 0., 0);
  TESTTOD(".e0", 0., 0);
  TESTTOD(".0e0", 0., LEN);
  TESTTOD(".0.e0", 0., 2);
  TESTTOD("1p0", 1., 1);

  // Normal numbers
  TESTEXACTNE(12.345);
  TESTEXACTNE(12.3456);
  TESTEXACTNE(12.34567);
  TESTEXACTNE(123.456);
  TESTEXACTNE(123.4567);
  TESTEXACTNE(123);
  TESTEXACTNE(1234567890123456789012345);
  TESTEXACT  (123.456e3);
  TESTEXACTNE(3.14159);
  TESTEXACTNE(0000000314.159000000);
  TESTEXACTNE(3.14159265);
  TESTEXACTNE(3.141592653);
  TESTEXACTNE(3.141592653589793);
  TESTEXACTNE(3.141592653589793238);
  TESTEXACTNE(3.1415926535897932384);
  TESTEXACTNE(3.1415926535897932384626);
  TESTEXACTNE(3141592653589793);
  TESTEXACTNE(31415926535897932);
  TESTEXACTNE(3141592653589793238);
  TESTEXACTNE(31415926535897932384);
  TESTEXACTNE(3141592653589793238462.6433);
  TESTEXACTNE(0.00000031415926535897932384626433);
  TESTEXACTNE(0.0000031415926535897932384626433);
  TESTEXACT  (0.0000031415926535897932384626433e5);
  TESTEXACT  (0.00000031415926535897932384626433e6);

  // Denormals
  TESTEXACT_E(4.940656458412466e-324);
  TESTEXACT_E(4.94065645841246544176e-324);
  TESTEXACT_E(4.940656458412465441765687928682213723650598e-324);
  TESTEXACT_E(49.40656458412465441765687928682213723650598e-325);
  TESTEXACT_E(494.0656458412465441765687928682213723650598e-326);
//  TESTEXACT(4.940656458412465441765687928682213723650598026143247644255856825006755072702087518652998363616359923797965646954457177309266567103559397963987747960107818781263007131903114045278458171678489821036887186360569987307230500063874091535649843873124733972731696151400317153853980741262385655911710266585566867681870395603106249319452715914924553293054565444011274801297099995419319894090804165633245247571478690147267801593552386115501348035264934720193790268107107491703332226844753335720832431936092382893458368060106011506169809753078342277318329247904982524730776375927247874656084778203734469699533647017972677717585125660551199131504891101451037862738167250955837389733598993664809941164205702637090279242767544565229087538682506419718265533447265625e-324);

  // Overflow
  TESTTOD_E("1e309", INFINITY, LEN);
  TESTTOD_E("1.e+322", INFINITY, LEN);
  TESTTOD_E(".01e+322", INFINITY, LEN);
  TESTEXACT(.000000000000001e+322); // no overflow in this case
  TESTEXACT(1.7976931348623157e+308);


  // keywords
  TESTEXACT(INFINITY);
  TESTEXACT(-INFINITY);
  TESTEXACT(NAN);
  TESTTOD("nan", NAN, LEN);
  TESTTOD("-nan", -NAN, LEN); // libc6 2.24 doesn't use the sign; 2.28 does
  TESTTOD("INF", INFINITY, LEN);
  TESTTOD("inf", INFINITY, LEN);
  TESTTOD("infinity", INFINITY, LEN);
  TESTTOD("inFiniTy", INFINITY, LEN);
  TESTTOD("infinite", INFINITY, 3);
  TESTTOD("infinities", INFINITY, 3);
  TESTTOD("-infinity", -INFINITY, LEN);
  TESTTOD("-infinite", -INFINITY, 4);
  TESTTOD("nano", NAN, 3);
  TESTTOD("-nano", -NAN, 4);
  TESTTOD("NAN(", NAN, 3);
  TESTTOD("NAN()", NAN, LEN);
  TESTTOD("NANO()", NAN, 3);
  TESTTOD("NAN(()", NAN, 3);
  TESTTOD("nan(.)", NAN, 3);
  TESTTOD("nan(_)", NAN, LEN);
  TESTTOD("nan(0)", NAN, LEN);
  TESTTOD("nan(zyxwv9876543210)", NAN, LEN);
  TESTTOD("nan(zyxwv9876543210))", NAN, 20);
  TESTTOD("nan(341y)", NAN, LEN);
  TESTTOD("nan(341+y)", NAN, 3);
  TESTTOD("-inf", -INFINITY, LEN);
  TESTTOD("ind", 0.0, 0);
  TESTTOD("-ind", 0.0, 0);
  TESTTOD("nax", 0.0, 0);
  TESTTOD("-nax", 0.0, 0);
  TESTTOD("nix", 0.0, 0);
  TESTTOD("-nix", 0.0, 0);
  TESTTOD("xix", 0.0, 0);
  TESTTOD("-xix", 0.0, 0);

  if (errors)
    printf("* %d failed tests\n", errors);
  else
    printf("* PASS\n");
  return 0;
}
